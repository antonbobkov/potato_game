:::POTATO MESSAGES:::

:establishing connection:
- A->B connect request [conn_uuid, challenge, identity {A, B}]
  - spam when initiating connection
  - retry every 10 minutes
- B->A connect response [conn_uuid, B signed challenge, challenge]
  - B now stores {conn_uuid, A} in active connections
- A->B connect response response [conn_uuid, A signed challenge]
  - A now stores {conn_uuid, B} in active connections
- A<->B ping
  - periodic message to indicate the connection is still alive

:blocks:
- A->B request block
  - B server caches request {A, blockrange} and starts serving
  - A should spam this request to ensure receipt
    - can stop spamming when first block is received
- B->A send block (either in response to request or when new block is made)
  - how should A re-request dropped blocks?

:potato TCP msg:
- TCP nonsense built over UDP
  - prob easier just to use TCP...

:txs:
- A->B send tx (that's it)

- client/servers can request for blocks via TCP/IP?
  (alternatively, just host blocks via http?)


:::TCP p2p spec:::

1 connection per verifier/player per game. i.e. two verifiers may have more than one connection with each other

::supersocket (listener)::
- supersocket supervisor that spawns several supersocket_tcplistener gen_server actors to listen for new connections
- upon receiving new connection, passes connection off to handshake_reply

::superclient::
- superviosr that accepts requests to create new connection
- creates a connection. Tries to connect several times up to a timeout period
- upon making a connection, hands it off to handshaker

::handshaker::
- handshaker supervisor receives request to start new handshaker either from superclient or from supersocket
- sends identification + challenge to be signed
- receives identification + challenge, signs and sends back
- receives challenge response, verifies
- if any of the above step fails, close the socket and terminate
- if all succeed, pass socket on to connection supervisor

::connection supervisor::
- upon receiving new connection, check if it already exists, if so pick deterministically
- either close the socket or terminate the existing socket if one exists already
- create connection actor to manage the socket, store this in some priority sorted list or whatever
- to create the connection, use handshake data to determine which game it gets assigned
- if too many connection, remove one of lower priority

::connection::
- create connection with PID of game manager
- terminate connection in game manager dies
- pass all messages to game manager


:::game manager:::
TODO


:::web3:::
TODO
