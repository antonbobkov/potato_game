<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>/home/antongml/offline_projects/potato_game/erlang/potatoserver/_build/test/cover/aggregate/blocktree_test.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /home/antongml/offline_projects/potato_game/erlang/potatoserver/_build/test/lib/potatoserver/test/blocktree_test.erl by COVER 2018-09-03 at 22:34:20

****************************************************************************

        |  -module(blocktree_test).
        |  
        |  -include_lib("eunit/include/eunit.hrl").
        |  
        |  -include_lib("stdlib/include/assert.hrl").
        |  
        |  -include("../src/potato_records.hrl").
        |  
        |  get_next_nonce(Id, TD) -&gt;
    33..|      Map = TD#tree_data.transaction_map,
    33..|      Result = maps:find(Id, Map),
    33..|      case Result of
        |  	{ok, TransactionArray} -&gt;
    23..|  	    array:size(TransactionArray);
        |  	error -&gt;
    10..|  	    0
        |      end.
        |  
        |  add_transaction(next, Id, TD) -&gt;
<font color=red>     0..|      NextNonce = get_next_nonce(Id, TD),</font>
<font color=red>     0..|      add_transaction(NextNonce, Id, TD);</font>
        |  add_transaction(Nonce, Id, TD) -&gt;
    35..|      T = #{nonce =&gt; Nonce, player_id =&gt; Id},
    35..|      blocktree:add_new_transaction(T, TD).
        |  
        |  add_mult_trans({Count, _}, TD) when Count == 0 -&gt;
    16..|      TD;
        |  add_mult_trans({Count, Id}, TD) when Count &gt; 0 -&gt;
    33..|      NextNonce = get_next_nonce(Id, TD),
    33..|      {_Msg, NewTD} = add_transaction(NextNonce, Id, TD),
        |      %% io:format("~p ~p ~p ~n", [Id, NextNonce, Msg]),
    33..|      add_mult_trans({Count-1, Id}, NewTD).
        |  
        |  add_new_transaction_test() -&gt;
     1..|      TD = #tree_data{transaction_map=maps:new()},
        |  
     1..|      ?assertMatch({ignore_nonce_too_high, _}, add_transaction(1, p1, TD)),
        |  
     1..|      L = [{2, p1}, {3, p2}, {2, p1}],
     1..|      TD1 = lists:foldl(fun add_mult_trans/2, TD, L),
        |      %% io:format("~p ~n", [TD1]),
        |  
        |  
     1..|      MP = TD1#tree_data.transaction_map,
     1..|      ?assert(maps:size(MP) == 2),
     1..|      ?assert(array:size(maps:get(p1, MP)) == 4),
     1..|      ?assert(array:size(maps:get(p2, MP)) == 3),
        |  
     1..|      ?assertMatch({ignore_duplicate, _}, add_transaction(1, p1, TD1)),
        |  
     1..|      T = #{nonce =&gt; 1, player_id =&gt; p1, game_data =&gt; stuff},
     1..|      ?assertThrow(_, blocktree:add_new_transaction(T, TD1)),
        |  
     1..|      TD1.
        |  
        |  add_empty_genesis_test() -&gt;
     1..|      TD = #tree_data{transaction_map=maps:new(), block_map=maps:new()},
     1..|      Block = #{previous_id =&gt; undefined, this_id =&gt; 0, height =&gt; 0, transactions =&gt; []},
     1..|      TD1 = blocktree:add_new_block(Block, TD),
        |  
     1..|      BMP = TD1#tree_data.block_map,
     1..|      ?assert(maps:size(BMP) == 1),
     1..|      ?assert(maps:get(0, BMP) == Block),
        |  
     1..|      TD1.
        |  
        |  map_of_arrays_to_list(Map) -&gt;
     1..|      M = maps:map(fun (_, A) -&gt; array:to_list(A) end, Map),
     1..|      maps:fold(fun (_, L, Acc) -&gt; L ++ Acc end, [], M).
        |  
        |  add_tr_genesis_test() -&gt;
     1..|      TD = #tree_data{transaction_map=maps:new(), block_map=maps:new()},
     1..|      L = [{2, p1}, {3, p2}, {2, p1}],
     1..|      TDD = lists:foldl(fun add_mult_trans/2, TD, L),
        |  
     1..|      Block = #{previous_id =&gt; undefined, this_id =&gt; 0, height =&gt; 0,
        |  		   transactions =&gt; map_of_arrays_to_list(TDD#tree_data.transaction_map)},
        |  		   %% transactions = TD1#tree_data.transaction_map},
     1..|      TD1 = blocktree:add_new_block(Block, TD),
        |  
     1..|      MP = TD1#tree_data.transaction_map,
     1..|      ?assert(maps:size(MP) == 2),
     1..|      ?assert(array:size(maps:get(p1, MP)) == 4),
     1..|      ?assert(array:size(maps:get(p2, MP)) == 3),
        |  
     1..|      BMP = TD1#tree_data.block_map,
     1..|      ?assert(maps:size(BMP) == 1),
     1..|      ?assert(maps:get(0, BMP) == Block),
        |  
     1..|      TD1.
        |  
        |  make_block(PrevId, ThisId, Height, TrLs) -&gt;
     4..|      Fn = fun({N, Id}, Ls) -&gt;
    13..|  		 T = #{nonce =&gt; N, player_id =&gt; Id},
    13..|  		 [T | Ls]
        |  	 end,
     4..|      Transactions = lists:reverse(lists:foldl(Fn, [], TrLs)),
        |  
     4..|      #{previous_id =&gt; PrevId, this_id =&gt; ThisId, height =&gt; Height,
        |  		   transactions  =&gt;  Transactions}.
        |  
        |  add_tr_genesis_2_test() -&gt;
     1..|      TD = #tree_data{transaction_map=maps:new(), block_map=maps:new()},
        |  
     1..|      Block = make_block(undefined, hi, 0, [{0, p1}, {0, p2}, {1, p1}]),
        |  
     1..|      TD1 = blocktree:add_new_block(Block, TD),
        |  
     1..|      MP = TD1#tree_data.transaction_map,
     1..|      ?assert(maps:size(MP) == 2),
     1..|      ?assert(array:size(maps:get(p1, MP)) == 2),
     1..|      ?assert(array:size(maps:get(p2, MP)) == 1),
        |  
     1..|      BMP = TD1#tree_data.block_map,
     1..|      ?assert(maps:size(BMP) == 1),
     1..|      ?assert(maps:get(hi, BMP) == Block),
        |  
     1..|      TD1.
        |  
        |  mult_blocks_test() -&gt;
     1..|      TD = #tree_data{},
        |  
     1..|      Ba = make_block(undefined, a, 0, [{0, p1}, {0, p2}, {1, p1}]),
     1..|      Bb = make_block(a, b, 1, [{1, p2}, {2, p1}, {0, p3}]),
     1..|      Bc = make_block(a, c, 1, [{2, p1}, {1, p2}, {0, p4}, {2, p2}]),
        |  
     1..|      Batch = [Ba, Bb, Bc],
        |  
     1..|      TD1 = lists:foldl(fun blocktree:add_new_block/2, TD, Batch),
        |  
     1..|      MP = TD1#tree_data.transaction_map,
     1..|      ?assert(maps:size(MP) == 4),
     1..|      ?assert(array:size(maps:get(p1, MP)) == 3),
     1..|      ?assert(array:size(maps:get(p2, MP)) == 3),
     1..|      ?assert(array:size(maps:get(p3, MP)) == 1),
     1..|      ?assert(array:size(maps:get(p4, MP)) == 1),
        |  
     1..|      BMP = TD1#tree_data.block_map,
     1..|      ?assert(maps:size(BMP) == 3),
        |  
     1..|      ?assertEqual(length(blocktree:get_all_longest_branches(TD1)), 2),
        |  
     1..|      TD1.
        |  
        |  generate_block_gen_test() -&gt;
     1..|      TD = #tree_data{},
        |  
     1..|      L = [{2, p1}, {3, p2}, {2, p1}],
     1..|      TD1 = lists:foldl(fun add_mult_trans/2, TD, L),
        |  
     1..|      B = blocktree:generate_new_block(undefined, TD1),
        |  
     1..|      ?assert(length(maps:get(transactions, B)) == 7),
        |  
     1..|      B.
        |  
        |  
        |  generate_block_mult_seq_test() -&gt;
     1..|      TD = #tree_data{},
        |  
     1..|      L1 = [{2, p1}, {3, p2}],
     1..|      L2 = [{1, p1}, {3, p3}, {1, p2}],
     1..|      L3 = [{1, p2}, {1, p4}],
        |  
     1..|      Batch = [L1, L2, L3],
        |  
     1..|      Fn = fun (L, TD0) -&gt;
     3..|  		 Id = maps:size(TD0#tree_data.block_map),
        |  
     3..|  		 if
     1..|  		     Id == 0 -&gt; PrevId = undefined;
     2..|  		     Id /= 0 -&gt; PrevId = Id - 1
        |  		 end,
        |  
     3..|  		 TD1 = lists:foldl(fun add_mult_trans/2, TD0, L),
     3..|  		 B = (blocktree:generate_new_block(PrevId, TD1))#{this_id := Id},
     3..|  		 TD2 = blocktree:add_new_block(B, TD1),
     3..|  		 TD2
        |  	 end,
        |  
     1..|      TD1 = lists:foldl(Fn, TD, Batch),
        |  
     1..|      BMP = TD1#tree_data.block_map,
     1..|      ?assert(maps:size(BMP) == 3),
     1..|      ?assert(length(maps:get(transactions, maps:get(0, BMP))) == 5),
     1..|      ?assert(length(maps:get(transactions, maps:get(1, BMP))) == 5),
     1..|      ?assert(length(maps:get(transactions, maps:get(2, BMP))) == 2),
        |  
     1..|      blocktree:get_block_by_id(0, TD1),
     1..|      blocktree:get_block_by_id(2, TD1),
        |  
     1..|      ?assertError(_, blocktree:get_block_by_id(5, TD1)),
     1..|      ?assertError(_, blocktree:get_block_by_id(hi, TD1)),
        |  
     1..|      ?assertEqual(length(blocktree:get_all_longest_branches(TD1)), 1),
        |  
     1..|      TD1.
        |  
        |    get_all_longest_branches_test() -&gt;
     1..|      TD0 = #tree_data{transaction_map=maps:new(), block_map=maps:new()},
     1..|      Block0 = #{previous_id =&gt; undefined, this_id =&gt; 0, height =&gt; 0, transactions =&gt; []},
     1..|      Block1 = #{previous_id =&gt; 0, this_id =&gt; 1, height =&gt; 1, transactions =&gt; []},
     1..|      Block2 = #{previous_id =&gt; 1, this_id =&gt; 2, height =&gt; 2, transactions =&gt; []},
        |      %% fork from genesis
     1..|      Block3 = #{previous_id =&gt; 0, this_id =&gt; 3, height =&gt; 1, transactions =&gt; []},
     1..|      Block4 = #{previous_id =&gt; 1, this_id =&gt; 4, height =&gt; 2, transactions =&gt; []},
     1..|      TD1 = blocktree:add_new_block(Block0, TD0),
     1..|      TD2 = blocktree:add_new_block(Block1, TD1),
     1..|      TD3 = blocktree:add_new_block(Block2, TD2),
     1..|      TD4 = blocktree:add_new_block(Block3, TD3),
     1..|      TD5 = blocktree:add_new_block(Block4, TD4),
     1..|      ?assertEqual(length(blocktree:get_all_longest_branches(TD5)), 2),
     1..|      TD5.
</pre>
</body>
</html>
